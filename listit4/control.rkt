#lang racket/base

;;;
;;; CONTROL
;;;

; The interface between the web-server in "server.rkt" and the control
; is the function `dispatch`. Each time the web-server receives an request
; it is passes on to `dispatch`.

(provide dispatch)

;; Imports

(require (for-syntax racket/base)
         racket/format
         racket/match
         racket/promise
         racket/runtime-path
         web-server/dispatch/extend
         web-server/servlet-env
         web-server/servlet
         web-server/http/redirect
         web-server/http/cookie
         web-server/http/id-cookie ; authenticated cookies
         web-server/dispatchers/dispatch-files
         web-server/dispatchers/dispatch
         ; "config.rkt"
         "def.rkt" "exn.rkt" "parameters.rkt" "structs.rkt"
         "validation.rkt"
         "model.rkt" "view.rkt")

;;;
;;; Utils
;;;

(define (bytes->number b)
  (string->number (bytes->string/utf-8 b)))

;;;
;;; Bindings
;;;

; get-binding
;   Extract a binding from the request if present and then
;   apply convert to the extracted value.
;   Typical use:  (get-binding #"username" bytes->string-utf/8)
(define (get-binding binding-name [convert values] #:request [req (current-request)])
  (match (bindings-assq binding-name (request-bindings/raw req))
    [(? binding:form? b) (convert (binding:form-value b))]
    [_ #f]))

;;;
;;; Cookies
;;;

; We are going to store session information (such as login status)
; on the client in cookies. To make these tamper proof, we need
; a way to verify, that they haven't been changed by the user.

; In order to store `authored-seconds&data` we send
; `digest&authored-seconds&data` where digest is a
; cryptographics hash of authored-seconds&data and, very important,
; a secret salt only known to the server(s).
; If using multiple servers, they need to share the secret salt.

; In short: we are not encrypting the data, we are merely
; associating it with a digest, so it can't be altered.

(define-runtime-path cookie-salt.bin "cookie-salt.bin")
(def cookie-salt (make-secret-salt/file cookie-salt.bin))

(define (make-logged-in-cookie)
  (make-id-cookie "login-status" "in"
                  #:key        cookie-salt
                  ; only for http/https (not client side javascript)
                  #:http-only? #t           
                  ; #:expires ...
                  ; #:max-age ...                            
                  ; #:secure? #t  ; instructs client only to send cookie via https
                  ))

(define (make-logged-out-cookie)
  (make-id-cookie "login-status" "out"
                  #:key cookie-salt
                  #:http-only? #t))


(define (make-username-cookie username)
  (make-id-cookie "username" username
                  #:key        cookie-salt
                  #:http-only? #t))

(define (get-cookie-value req name)
  (request-id-cookie req #:name name #:key  cookie-salt
                     ; #:timeout ...
                     ; #:shelf-life ...
                     ))

(define (get-login-status req)
  (match (get-cookie-value req "login-status")
    ["in" #t]
    [_    #f]))
                     
;;;
;;; DISPATCH
;;;

; from web-server/dispatch/url-patterns
(define-syntax define-bidi-match-expander/coercions
  (syntax-rules ()
    [(_ id in-test? in out-test? out)
     (begin (define-coercion-match-expander in/m in-test? in)
            (define-coercion-match-expander out/m out-test? out)
            (define-bidi-match-expander id in/m out/m))]))

;; (define string->integer? (make-coerce-safe? string->integer))
;; (define-bidi-match-expander/coercions integer-arg
;;   string->integer? string->integer
;;   integer? number->string)

(define (vote-direction? x) (or (equal? x "up") (equal? x "down")))
(define-bidi-match-expander/coercions vote-direction-arg
  vote-direction? values vote-direction?  values)

(define (popular-period? x) (member x (list "day" "week" "month" "year" "all")))
(define-bidi-match-expander/coercions popular-period-arg
  popular-period? values popular-period?  values)

(define (dispatch req)
  (current-request req)
  (def login-status (get-login-status req))
  (def username     (and login-status (get-cookie-value req "username")))
  (def user         (and username (get-user #:username username)))
  
  (parameterize ([current-login-status (and user login-status)]
                 [current-user         (and login-status user)])
    (displayln (url->string (request-uri req)))

    (dispatch-on-url req)))

; (def entry-id-arg    integer-arg)
; (def page-number-arg integer-arg)

(defv (dispatch-on-url generate-url)
  ; pages:   show a given html page (generated by the view)
  ; actions: performs action, then redirects to a page
  (dispatch-rules
   ; pages
   [("")                                          (λ (req) (do-home req 0))]                 
   [("home")                                      (λ (req) (do-home req 0))]
   [("home" "page" (integer-arg))                 do-home]
   [("new")                                       (λ (req) (do-new req 0 ))]
   [("new" "page" (integer-arg))                  do-new]
   [("popular")                                   (λ (req) (do-popular req "week" 0))]
   [("popular" (popular-period-arg)
               "page" (integer-arg))              do-popular]
   [("user" (string-arg))                         do-user]
   [("from" (integer-arg))                        do-from]  ; entries from same site as entry-id
   [("about")                                     do-about]                
   [("login")                                     do-login/create-account] 
   [("submit")                                    do-submit]               ; new entry page
   
   ; actions
   ;   only recognize up-votes - use the next line if you need both
   [("vote" "up" (integer-arg) (integer-arg)) #:method "post"  (λ (req e p) (do-vote req "up" e p))]
   ; [("vote" "up" (entry-id-arg) (page-number-arg)) #:method "post"  (λ (reg e p) (do-vote "up" e p))]
   ; [("vote" (vote-direction-arg) (integer-arg) (integer-arg)) #:method "post"  do-vote]
   
   [("login-to-vote")                             do-login-to-vote]
   [("login-to-submit")                           do-login-to-submit]
   [("resubmission")                              do-resubmission]

   ; form submissions
   [("logout-submitted")         #:method "post"  do-logout-submitted] ; logout, then show front page
   [("entry-submitted")          #:method "post"  do-entry-submitted]
   [("login-submitted")          #:method "post"  do-login-submitted]
   [("create-account-submitted") #:method "post"  do-create-account-submitted]
   ; no else clause means the next dispatch ought to serve other files


   ; [("favicons" (string-arg))                     (λ(_ __) (next-dispatcher))]
   #;[else
    (λ (req)
      (displayln "!!!")
      (displayln (url->string (request-uri req)))
      (displayln (request-method req))
      (do-home req 0))]
   ))

;;;
;;; PAGES
;;;

(define (do-about req)
  (def result (html-about-page))
  (response/output (λ (out) (display result out))))


; The home, new and popular pages are very similar.
; They display a list of entries in some order.
; We have one function in the view  html-list-page,
; that handle all three cases.

(define (do-home req page-number)
  (def first-rank  (+ 1 (* page-number (PAGE-LIMIT))))
  (def entries     (newest page-number)) ; this will like change at some point
  (def result      (html-list-page "home" page-number first-rank entries))
  (response/output (λ (out) (display result out))))

(define (do-new req page-number)
  (def first-rank (+ 1 (* page-number (PAGE-LIMIT))))
  (def entries    (newest page-number))
  (def result     (html-list-page "new" page-number first-rank entries))
  (response/output (λ (out) (display result out))))

(define (do-popular req period page-number)
  (displayln (list 'do-popular period page-number))
  (def first-rank  (+ 1 (* page-number (PAGE-LIMIT))))
  (def entries     (popular (string->symbol period) page-number))

  (def result      (html-popular-page page-number first-rank entries period))
  (response/output (λ (out) (display result out))))



(define (do-user req username)
  (def u (get-user username))
  (def result (html-user-page u))
  (response/output (λ (out) (display result out))))

(define (do-from req entry-id)
  (def e (get-entry entry-id)) ; #f if not found
  (def s (and e (entry-site e)))
  (def entries (or (and e (from-site s)) '()))
  (def result (html-from-page entries))
  (response/output (λ (out) (display result out))))


(define (do-login-to-vote req)
  (parameterize ([current-banner-message "Login to vote."])
    (do-login/create-account req)))

(define (do-login-to-submit req)
  (parameterize ([current-banner-message "Login to submit."])
    (do-login/create-account req)))

(define (do-resubmission req)
  (parameterize ([current-banner-message "Your submission was submitted recently by another user."])
    (do-home req 0)))

(define (do-login/create-account req)
  (def result (html-login-page))
  (response/output (λ (out) (display result out))))

(define (do-logout-submitted req)
  (displayln "logging out")
  (def result (html-login-page))
  (redirect-to "/" temporarily
               #:headers (map cookie->header
                              (list (make-logged-out-cookie)))))

(define (do-login-submitted req)
  (displayln 'do-login-submitted)
  (def u  (get-binding #"username" bytes->string/utf-8))
  (def p  (get-binding #"password"))
  (displayln (list 'u u 'p p))
  (cond
    [(and u p) (match (authenticate-user u p)
                 ; On a successful login we generate a logged-in cookie,
                 ; and redirect to the frontpage.
                 ; The redirection prevents the form data being submitted
                 ; twice due to reloads in the browser.
                 [#t
                  (displayln (list 'do-submit-login "login ok"))
                  (redirect-to
                   "/" temporarily
                   #:headers (map cookie->header
                                  (list (make-username-cookie u)
                                        (make-logged-in-cookie))))]
                 ; If the login failed, the user must try again.
                 [(authentication-error msg)                  
                  (displayln (list 'do-submit-login msg))
                  (redirect-to "/login" temporarily)])]
    [else      (displayln (list 'do-submit-login 'u u 'p p))
               (redirect-to "/login" temporarily)]))

(define (do-create-account-submitted req)
  (def u (bytes->string/utf-8 (get-binding #"username")))
  (def p (get-binding #"password"))
  (def e (bytes->string/utf-8 (get-binding #"email")))
  (with-handlers ([exn:fail:user:bad?
                   (λ (e)
                     (def msg (exn-message e))
                     (displayln msg) ; todo: show user
                     (redirect-to "/login" temporarily))])
    (create-user u p e)
    (redirect-to "/" temporarily
                 #:headers (map cookie->header
                                (list (make-username-cookie u)
                                      (make-logged-in-cookie))))))
    


(define (do-vote req direction entry-id page-number) ; an arrow was clicked on the given page
  (match (current-login-status)
    [#t  ; logged-in
     (define (register dir)
       (register-vote #:user     (current-user)
                      #:entry-id entry-id
                      #:ip       (request-client-ip req)
                      #:dir      dir))
     (match direction
       ["up"   (register 'up)]
       ["down" (register 'down)]    
       [else    'do-nothing])
     ; to make sure a reload doesn't resubmit, we redirect to the front page
     (redirect-to (~a "/home/page/" page-number) temporarily)]
    
     ; logged-out
     [_ (redirect-to "/login-to-vote" temporarily)]))


(define (do-submit req)
  (def logged-in? (current-login-status))
  (cond [logged-in? (def result (html-submit-page))
                    (response/output (λ (out) (display result out)))]
        [else       (redirect-to "/login-to-submit" temporarily)]))

;;;
;;; do-submit
;;;

(define (do-entry-submitted req)
  (def logged-in? (current-login-status))
  (def u          (get-user (current-user)))
  ; We get here when the form on the "Submit new entry" page is submitted.
  (def url   (get-binding #"url"   bytes->string/utf-8))
  (def title (get-binding #"title" bytes->string/utf-8))
  (def ip    (request-client-ip req))
  
  ; If the submitted url and title are valid, we will insert an
  ; entry in the database and redirect to the database.
  ; Unless the submissions already is in the database, in which
  ; case we allow it if the previous submission is older than a month.
  
  ; If the data is invalid, we need to show the submit page again,
  ; this time with validation results.
  
  (define vu (validate-url   url))   ; see "validation.rkt" for definition
  (define vt (validate-title title))

  (cond
    [logged-in?
     (cond
       [(all-valid? vu vt)
        (def e (get-entry/url url))
        (cond
          [(and e (recent? e))
           ; entry already in database and recently
           ; if we had comments, we would redirect to the comments page
           (redirect-to "/resubmission")]
          [else
           (register-entry #:title title #:url url #:user u #:ip ip)
           ; to make sure a reload doesn't resubmit, we redirect to the front page
           (redirect-to "/" temporarily)])]
       [else
        (def result (html-submit-page #:validation (list vu vt)))
        (response/output
         #:headers (list (header #"Location" #"foo"))
         (λ (out) (display result out)))])]
    [else
     (redirect-to "/" temporarily)]))

